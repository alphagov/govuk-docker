resource_types:
- name: pull-request
  type: docker-image
  source:
    repository: teliaoss/github-pr-resource

resources:
- name: pull-request
  type: pull-request
  check_every: 1m
  webhook_token: ((govuk_docker_webhook_token))
  source:
    repository: alphagov/govuk-docker
    access_token: ((govuk_docker_github_api_token))

jobs:
- name: test
  plan:
  - get: pull-request
    trigger: true
    version: every
    params:
      integration_tool: checkout
  - put: pull-request
    params:
      path: pull-request
      status: pending
  - task: test
    privileged: true
    config:
      platform: linux
      image_resource:
        type: docker-image
        source:
          repository: ruby
          tag: "2.6.3-alpine"
      inputs:
        - name: pull-request
      run:
        path: /bin/sh
        args:
          - -ce
          - |
            echo "preparing..."

            apk add gcc libc-dev make

            ### BEGIN code copied from https://github.com/meAmidos/dcind (MIT licensed, copyright Dmitry Matrosov <amidos@amidos.me>)
            export DOCKER_VERSION=17.05.0-ce
            export DOCKER_COMPOSE_VERSION=1.24.0
            export ENTRYKIT_VERSION=0.4.0

            # Install Docker and Docker Compose
            apk --update --no-cache add curl util-linux device-mapper py-pip iptables
            rm -rf /var/cache/apk/*
            curl https://get.docker.com/builds/Linux/x86_64/docker-${DOCKER_VERSION}.tgz | tar zx
            mv docker/* /bin/ && chmod +x /bin/docker*
            pip install docker-compose==${DOCKER_COMPOSE_VERSION}

            # Install entrykit
            curl -L https://github.com/progrium/entrykit/releases/download/v${ENTRYKIT_VERSION}/entrykit_${ENTRYKIT_VERSION}_Linux_x86_64.tgz | tar zx
            chmod +x entrykit
            mv entrykit /bin/entrykit
            entrykit --symlink

            # start docker
            sanitize_cgroups() {
              mkdir -p /sys/fs/cgroup
              mountpoint -q /sys/fs/cgroup || \
                mount -t tmpfs -o uid=0,gid=0,mode=0755 cgroup /sys/fs/cgroup

              mount -o remount,rw /sys/fs/cgroup

              sed -e 1d /proc/cgroups | while read sys hierarchy num enabled; do
                if [ "$enabled" != "1" ]; then
                  # subsystem disabled; skip
                  continue
                fi

                grouping="$(cat /proc/self/cgroup | cut -d: -f2 | grep "\\<$sys\\>")"
                if [ -z "$grouping" ]; then
                  # subsystem not mounted anywhere; mount it on its own
                  grouping="$sys"
                fi

                mountpoint="/sys/fs/cgroup/$grouping"

                mkdir -p "$mountpoint"

                # clear out existing mount to make sure new one is read-write
                if mountpoint -q "$mountpoint"; then
                  umount "$mountpoint"
                fi

                mount -n -t cgroup -o "$grouping" cgroup "$mountpoint"

                if [ "$grouping" != "$sys" ]; then
                  if [ -L "/sys/fs/cgroup/$sys" ]; then
                    rm "/sys/fs/cgroup/$sys"
                  fi

                  ln -s "$mountpoint" "/sys/fs/cgroup/$sys"
                fi
              done
            }

            start_docker() {
              mkdir -p /var/log
              mkdir -p /var/run

              sanitize_cgroups

              # check for /proc/sys being mounted readonly, as systemd does
              if grep '/proc/sys\s\+\w\+\s\+ro,' /proc/mounts >/dev/null; then
                mount -o remount,rw /proc/sys
              fi

              local server_args=""

              for registry in $1; do
                server_args="${server_args} --insecure-registry ${registry}"
              done

              if [ -n "$2" ]; then
                server_args="${server_args} --registry-mirror=$2"
              fi

              if [ -n "$3" ]; then
                server_args="${server_args} -g=$3"
              fi

              docker daemon --data-root /scratch/docker ${server_args} >/tmp/docker.log 2>&1 &
              echo $! > /tmp/docker.pid

              trap stop_docker EXIT

              sleep 1

              until docker info >/dev/null 2>&1; do
                echo waiting for docker to come up...
                sleep 1
              done
            }

            stop_docker() {
              local pid=$(cat /tmp/docker.pid)
              if [ -z "$pid" ]; then
                return 0
              fi

              kill -TERM $pid
              wait $pid
            }
            ### END

            start_docker

            export GOVUK_ROOT=$(pwd)
            export GOVUK_DOCKER_DIR=$(pwd)/pull-request

            cd pull-request

            set -x

            bundle
            make test
    on_failure:
      put: pull-request
      params:
        path: pull-request
        status: failure
  - put: pull-request
    params:
      path: pull-request
      status: success
